<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Stoichiometry Practice – IGCSE</title>
  <style>
    :root{
      --primary:#2f8fda;
      --muted:#666;
      --card-bg:#fff;
      --surface:#f5f5f5;
      --success:#1b8a4a;
      --danger:#c0392b;
    }
    body{
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      max-width:900px;margin:0 auto;padding:1.5rem;background:var(--surface);color:#222;
    }
    h1{font-size:1.8rem;margin-bottom:.3rem;}
    .tagline{margin-bottom:1rem;font-size:.95rem;color:#555;}
    .card{background:var(--card-bg);border-radius:.75rem;padding:1rem 1.2rem;margin-bottom:1rem;box-shadow:0 2px 6px rgba(0,0,0,.08);}    
    .label{font-size:.85rem;font-weight:600;text-transform:uppercase;letter-spacing:.04em;color:#555;margin-bottom:.3rem;}
    .controls-row{margin-bottom:.5rem;display:flex;flex-wrap:wrap;align-items:center;gap:.5rem;}
    input[type="text"],input[type="number"],select{padding:.3rem .5rem;border-radius:.4rem;border:1px solid #ccc;font-size:1rem;box-sizing:border-box;max-width:100%}
    .controls-row input[type="text"]{flex:1 1 180px;min-width:0}
    .controls-row input[type="number"]{flex:0 0 160px;width:160px}
    .buttons{margin-top:.8rem;display:flex;gap:.5rem;flex-wrap:wrap}
    button{border:none;border-radius:999px;padding:.45rem .9rem;font-size:.9rem;cursor:pointer;background:var(--primary);color:#fff}
    button.secondary{background:#e0e0e0;color:#333}
    button:disabled{cursor:not-allowed;opacity:.6}
    .feedback{margin-top:.7rem;font-weight:600;font-size:.95rem}
    .feedback.correct{color:var(--success)}
    .feedback.incorrect{color:var(--danger)}
    .solution-steps{margin-top:.5rem;font-size:.9rem;line-height:1.4}
    .solution-steps p{margin:.2rem 0}
    .note{font-size:.8rem;color:var(--muted);margin-top:.3rem}
    .small{font-size:.85rem;color:#555}
    table{width:100%;border-collapse:collapse;font-size:.85rem;margin-top:.4rem}
    th,td{border-bottom:1px solid #eee;padding:.25rem .3rem;text-align:left}
    th{font-weight:600;background:#f7f7f7}
    .sr-only{position:absolute!important;height:1px;width:1px;overflow:hidden;clip:rect(1px,1px,1px,1px);white-space:nowrap}
    .muted{color:var(--muted)}
    .player-feedback{margin-top:.5rem;font-size:.9rem;color:var(--muted)}
    .player-feedback.success{color:var(--success);font-weight:600}
    .player-feedback.error{color:var(--danger);font-weight:600}
    .stats-grid{display:grid;grid-template-columns:1fr 1fr;gap:0.8rem}
    .small-muted{font-size:.8rem;color:var(--muted)}
  </style>
</head>
<body>
  <h1>Stoichiometry Practice</h1>
  <div class="tagline">
    Year 9/10 IGCSE practice – mass ↔ mass, mass ↔ gas volume, gas ↔ gas, concentration questions.
    Enter your answer to 2–3 s.f. The app accepts small rounding differences.
  </div>

  <!-- Player controls -->
  <div class="card" aria-labelledby="playerLabel">
    <div class="label" id="playerLabel">Player</div>
    <div class="controls-row" role="group" aria-label="Player controls">
      <label for="playerNameInput" class="sr-only">Player name</label>
      <input id="playerNameInput" type="text" placeholder="Enter your name or nickname" maxlength="32" aria-describedby="playerHelp">
      <div style="display:flex;gap:.5rem">
        <button id="setPlayerBtn">Set player</button>
        <button id="resetPlayerBtn" class="secondary" type="button">Reset</button>
      </div>
    </div>
    <div class="small" id="currentPlayerLabel">Current player: <strong aria-live="polite">Guest</strong></div>
    <div id="playerHelp" class="note">Leaderboard and stats are saved in this browser only (localStorage).</div>
    <div id="playerFeedback" class="player-feedback" aria-live="polite"></div>
  </div>

  <!-- Stats + Streak leaderboard -->
  <div class="card stats-grid" aria-labelledby="statsLabel">
    <div>
      <div class="label">Your stats</div>
      <div class="small-muted">Session and lifetime accuracy by question type</div>
      <table id="privateStatsTable" aria-live="polite">
        <thead><tr><th>Type</th><th>Session</th><th>Lifetime</th></tr></thead>
        <tbody></tbody>
      </table>
      <div class="small" style="margin-top:.5rem">
        Current streak: <strong id="currentStreak">0</strong>
        &nbsp;—&nbsp; Best streak (lifetime): <strong id="bestStreak">0</strong>
      </div>
    </div>

    <div>
      <div class="label">Global streak leaderboard</div>
      <div class="small-muted">Top players by highest consecutive-correct streak (lifetime)</div>
      <table id="streakLeaderboardTable" aria-live="polite">
        <thead><tr><th>Player</th><th>Max streak</th><th>Score</th><th>Attempts</th><th>Last</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Question card -->
  <div class="card">
    <div class="label">Question</div>

    <div class="controls-row" style="align-items:center" role="group" aria-label="Question type">
      <label for="questionTypeSelect" class="sr-only">Question type</label>
      <select id="questionTypeSelect" aria-label="Choose question type">
        <option value="random">Random</option>
        <option value="mass-mass">Mass → Mass</option>
        <option value="mass-gas">Mass → Gas volume</option>
        <option value="gas-gas">Gas → Gas (volume ratios)</option>
        <option value="conc-gpl">Concentration (g L⁻¹)</option>
        <option value="conc-mol">Concentration (mol L⁻¹)</option>
      </select>
      <div style="margin-left:auto;display:flex;gap:.5rem">
        <button id="newQuestionBtn" class="secondary" type="button">New question</button>
      </div>
    </div>

    <div id="questionArea">
      <div class="question-text" id="questionText">Click "New question" to begin.</div>
      <div class="question-meta muted" id="questionMeta"></div>

      <div class="controls-row" style="margin-top:.6rem">
        <label for="answerInput" class="sr-only">Your answer</label>
        <input id="answerInput" type="number" placeholder="Enter answer" step="any" >
        <span class="unit" id="answerUnit"></span>
        <div style="margin-left:auto;display:flex;gap:.5rem">
          <button id="checkAnswerBtn">Check</button>
        </div>
      </div>

      <div id="answerFeedback" class="feedback" aria-live="polite"></div>
      <div id="solutionSteps" class="solution-steps" style="display:none"></div>
    </div>
  </div>

  <!-- Classic leaderboard (score) -->
  <div class="card">
    <div class="label">Leaderboard</div>
    <div class="small-muted">Top players (this browser) — score and max streak</div>
    <table id="leaderboardTable" aria-live="polite">
      <thead><tr><th>Player</th><th>Score</th><th>Attempts</th><th>Last</th><th>Max streak</th></tr></thead>
      <tbody></tbody>
    </table>
    <div style="margin-top:.6rem;display:flex;gap:.5rem">
      <button id="clearLeaderboardBtn" class="secondary">Clear leaderboard</button>
    </div>
  </div>

  <noscript class="card">
    <div class="label">JavaScript required</div>
    <div class="description">This app needs JavaScript enabled to work. Please enable JavaScript in your browser.</div>
  </noscript>

  <script>
  (function(){
    /* Storage keys */
    const PLAYER_KEY = 'stoich.player';
    const LEADERBOARD_KEY = 'stoich.leaderboard';
    const LIFETIME_STATS_KEY = 'stoich.lifetimeStats';

    /* Constants */
    const MOLAR_VOLUME = 24.0; // L mol⁻¹
    const M_NaCl = 58.44;
    const QUESTION_TYPES = ['mass-mass','mass-gas','gas-gas','conc-gpl','conc-mol'];

    /* Reaction definitions */
    const REACTIONS = [
      {
        id: 'water-formation',
        eq: '2 H₂ + O₂ → 2 H₂O',
        computeMassFromH2: (mH2) => {
          const M_H2 = 2.016;
          const M_H2O = 18.015;
          const nH2 = mH2 / M_H2;
          const nH2O = nH2;
          const mH2O = nH2O * M_H2O;
          const steps = [
            `Balanced equation: 2 H₂ + O₂ → 2 H₂O`,
            `moles H₂ = ${mH2.toFixed(3)} / ${M_H2} = ${nH2.toFixed(4)} mol`,
            `moles H₂O = moles H₂ (1:1) = ${nH2O.toFixed(4)} mol`,
            `mass H₂O = ${nH2O.toFixed(4)} × ${M_H2O} = ${mH2O.toFixed(4)} g`
          ];
          return { value: mH2O, unit: 'g', steps };
        },
        computeO2FromH2Volume: (vH2) => {
          const vO2 = vH2 / 2;
          const steps = [
            `Balanced equation: 2 H₂ + O₂ → 2 H₂O`,
            `Volume ratio H₂ : O₂ = 2 : 1`,
            `Volume O₂ = ${vH2.toFixed(3)} L × (1/2) = ${vO2.toFixed(3)} L`
          ];
          return { value: vO2, unit: 'L', steps };
        }
      },
      {
        id: 'co2-formation',
        eq: 'C + O₂ → CO₂',
        computeMassFromC: (mC) => {
          const M_C = 12.01;
          const M_CO2 = 44.01;
          const nC = mC / M_C;
          const nCO2 = nC;
          const mCO2 = nCO2 * M_CO2;
          const steps = [
            `Balanced equation: C + O₂ → CO₂`,
            `moles C = ${mC.toFixed(3)} / ${M_C} = ${nC.toFixed(4)} mol`,
            `moles CO₂ = moles C (1:1) = ${nCO2.toFixed(4)} mol`,
            `mass CO₂ = ${nCO2.toFixed(4)} × ${M_CO2} = ${mCO2.toFixed(4)} g`
          ];
          return { value: mCO2, unit: 'g', steps };
        },
        computeVolumeCO2FromC: (mC) => {
          const M_C = 12.01;
          const nC = mC / M_C;
          const nCO2 = nC;
          const vol = nCO2 * MOLAR_VOLUME;
          const steps = [
            `Balanced equation: C + O₂ → CO₂`,
            `moles C = ${mC.toFixed(3)} / ${M_C} = ${nC.toFixed(4)} mol`,
            `moles CO₂ = moles C (1:1) = ${nCO2.toFixed(4)} mol`,
            `volume CO₂ = ${nCO2.toFixed(4)} × ${MOLAR_VOLUME} = ${vol.toFixed(4)} L`
          ];
          return { value: vol, unit: 'L', steps };
        }
      },
      {
        id: 'concentration',
        eq: '— (dissolving)',
        computeConcentration_g_per_L: (mass_g, volume_L) => {
          const conc = mass_g / volume_L;
          const steps = [
            `concentration = ${mass_g.toFixed(3)} g / ${volume_L.toFixed(3)} L = ${conc.toFixed(4)} g L⁻¹`
          ];
          return { value: conc, unit: 'g L⁻¹', steps };
        },
        computeConcentration_mol_per_L: (mass_g, volume_L, formulaMass=M_NaCl) => {
          const moles = mass_g / formulaMass;
          const conc = moles / volume_L;
          const steps = [
            `moles solute = ${mass_g.toFixed(3)} / ${formulaMass} = ${moles.toFixed(4)} mol`,
            `concentration = ${moles.toFixed(4)} mol / ${volume_L.toFixed(3)} L = ${conc.toFixed(4)} mol L⁻¹`
          ];
          return { value: conc, unit: 'mol L⁻¹', steps };
        }
      }
    ];

    /* DOM elements */
    const playerInput = document.getElementById('playerNameInput');
    const setPlayerBtn = document.getElementById('setPlayerBtn');
    const resetPlayerBtn = document.getElementById('resetPlayerBtn');
    const currentPlayerEl = document.querySelector('#currentPlayerLabel strong');
    const playerFeedbackEl = document.getElementById('playerFeedback');

    const questionTypeSelect = document.getElementById('questionTypeSelect');
    const questionTextEl = document.getElementById('questionText');
    const questionMetaEl = document.getElementById('questionMeta');
    const answerInput = document.getElementById('answerInput');
    const answerUnitEl = document.getElementById('answerUnit');
    const checkAnswerBtn = document.getElementById('checkAnswerBtn');
    const newQuestionBtn = document.getElementById('newQuestionBtn');
    const answerFeedbackEl = document.getElementById('answerFeedback');
    const solutionStepsEl = document.getElementById('solutionSteps');

    const leaderboardBody = document.querySelector('#leaderboardTable tbody');
    const streakLeaderboardBody = document.querySelector('#streakLeaderboardTable tbody');
    const privateStatsTableBody = document.querySelector('#privateStatsTable tbody');
    const currentStreakEl = document.getElementById('currentStreak');
    const bestStreakEl = document.getElementById('bestStreak');
    const clearLeaderboardBtn = document.getElementById('clearLeaderboardBtn');

    /* State */
    let currentQuestion = null;
    let lastResult = null;

    // Session stats (in-memory). Per-player session data keyed by player name.
    const sessionStats = {};

    /* Utilities */
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c]));
    }

    function roundToSignificantFigures(num, sig) {
      if (!isFinite(num) || num === 0) return 0;
      const mult = Math.pow(10, sig - Math.ceil(Math.log10(Math.abs(num))));
      return Math.round(num * mult) / mult;
    }

    function toSignificantString(num, sig) {
      if (!isFinite(num)) return String(num);
      return Number(num).toPrecision(sig).replace(/(?:\.0+|([\.]\d+?)0+)$/, '$1');
    }

    function relativeError(a,b){
      if (!isFinite(a) || !isFinite(b) || b === 0) return Math.abs(a-b);
      return Math.abs(a-b)/Math.abs(b);
    }

    function isAcceptable(userValue, correctValue){
      if (!isFinite(userValue) || !isFinite(correctValue)) return false;
      const relErr = relativeError(userValue, correctValue);
      if (relErr <= 0.02) return {ok:true, reason:'within 2% relative error', relErr};

      const correct2 = roundToSignificantFigures(correctValue, 2);
      const correct3 = roundToSignificantFigures(correctValue, 3);
      const user2 = roundToSignificantFigures(userValue, 2);
      const user3 = roundToSignificantFigures(userValue, 3);

      if (user2 === correct2) return {ok:true, reason:'matches 2 s.f.', relErr};
      if (user3 === correct3) return {ok:false, reason:'outside tolerance', relErr};
      return {ok:false, reason:'outside tolerance', relErr};
    }

    /* Persistent storage helpers */
    function loadLeaderboard(){
      try { const raw = localStorage.getItem(LEADERBOARD_KEY); return raw ? JSON.parse(raw) : []; } catch(e){ return []; }
    }
    function saveLeaderboard(list){
      try { localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(list)); return true; } catch(e){ return false; }
    }
    function loadLifetimeStats(){
      try { const raw = localStorage.getItem(LIFETIME_STATS_KEY); return raw ? JSON.parse(raw) : {}; } catch(e){ return {}; }
    }
    function saveLifetimeStats(obj){
      try { localStorage.setItem(LIFETIME_STATS_KEY, JSON.stringify(obj)); return true; } catch(e){ return false; }
    }

    /* Leaderboard rendering (score and streak) */
    function renderLeaderboard(){
      const list = loadLeaderboard();
      // For the main leaderboard sort by score desc
      const listByScore = [...list].sort((a,b) => (b.score - a.score) || (a.attempts - b.attempts) || (new Date(b.last) - new Date(a.last)));
      leaderboardBody.innerHTML = '';
      if (listByScore.length === 0){
        const tr = document.createElement('tr');
        tr.innerHTML = '<td colspan="5" class="muted">No entries yet</td>';
        leaderboardBody.appendChild(tr);
      } else {
        for (const entry of listByScore.slice(0,50)){
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${escapeHtml(entry.name)}</td><td>${entry.score}</td><td>${entry.attempts}</td><td class="muted">${new Date(entry.last).toLocaleString()}</td><td>${entry.maxStreak || 0}</td>`;
          leaderboardBody.appendChild(tr);
        }
      }

      // Streak leaderboard (by maxStreak desc)
      const listByStreak = [...list].sort((a,b) => (b.maxStreak - a.maxStreak) || (b.score - a.score));
      streakLeaderboardBody.innerHTML = '';
      if (listByStreak.length === 0){
        const tr = document.createElement('tr');
        tr.innerHTML = '<td colspan="5" class="muted">No entries yet</td>';
        streakLeaderboardBody.appendChild(tr);
      } else {
        for (const entry of listByStreak.slice(0,50)){
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${escapeHtml(entry.name)}</td><td>${entry.maxStreak || 0}</td><td>${entry.score}</td><td>${entry.attempts}</td><td class="muted">${new Date(entry.last).toLocaleString()}</td>`;
          streakLeaderboardBody.appendChild(tr);
        }
      }
    }

    /* Lifetime stats rendering for current player */
    function renderPrivateStatsFor(player){
      const lifetime = loadLifetimeStats();
      const pstats = lifetime[player] || { attemptsByType: {}, correctByType: {}, bestStreak: 0 };
      const sess = sessionStats[player] || { attemptsByType: {}, correctByType: {}, currentStreak: 0, bestStreak: 0 };

      // ensure all types present
      privateStatsTableBody.innerHTML = '';
      for (const t of QUESTION_TYPES){
        const sAttempts = sess.attemptsByType[t] || 0;
        const sCorrect = sess.correctByType[t] || 0;
        const lAttempts = pstats.attemptsByType[t] || 0;
        const lCorrect = pstats.correctByType[t] || 0;
        const sPct = sAttempts ? Math.round((sCorrect / sAttempts) * 100) + '%' : '-';
        const lPct = lAttempts ? Math.round((lCorrect / lAttempts) * 100) + '%' : '-';
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${t}</td><td>${sCorrect}/${sAttempts} (${sPct})</td><td>${lCorrect}/${lAttempts} (${lPct})</td>`;
        privateStatsTableBody.appendChild(tr);
      }

      currentStreakEl.textContent = sess.currentStreak || 0;
      bestStreakEl.textContent = pstats.bestStreak || sess.bestStreak || 0;
    }

    /* Record result: updates leaderboard score/attempts and streaks and lifetime stats */
    function recordResult(playerName, deltaScore, questionType, wasCorrect){
      if (!playerName) return;

      // Update leaderboard entry (score, attempts, last, maxStreak)
      const list = loadLeaderboard();
      const now = new Date().toISOString();
      let entry = list.find(e => e.name === playerName);
      if (!entry){
        entry = { name: playerName, score: 0, attempts: 0, last: now, maxStreak: 0 };
        list.push(entry);
      }
      entry.score += deltaScore;
      entry.attempts += 1;
      entry.last = now;

      // Manage session streaks
      if (!sessionStats[playerName]) {
        sessionStats[playerName] = { attemptsByType: {}, correctByType: {}, currentStreak: 0, bestStreak: 0 };
      }
      const sess = sessionStats[playerName];

      // Update session counts
      sess.attemptsByType[questionType] = (sess.attemptsByType[questionType] || 0) + 1;
      if (wasCorrect) sess.correctByType[questionType] = (sess.correctByType[questionType] || 0) + 1;

      // Update current streak and session best
      if (wasCorrect){
        sess.currentStreak = (sess.currentStreak || 0) + 1;
        if (sess.currentStreak > sess.bestStreak) sess.bestStreak = sess.currentStreak;
      } else {
        sess.currentStreak = 0;
      }

      // Update lifetime stats
      const lifetime = loadLifetimeStats();
      if (!lifetime[playerName]) {
        lifetime[playerName] = { attemptsByType: {}, correctByType: {}, bestStreak: 0 };
      }
      const lp = lifetime[playerName];
      lp.attemptsByType[questionType] = (lp.attemptsByType[questionType] || 0) + 1;
      if (wasCorrect) lp.correctByType[questionType] = (lp.correctByType[questionType] || 0) + 1;

      // Update lifetime best streak and leaderboard maxStreak
      lp.bestStreak = Math.max(lp.bestStreak || 0, sess.currentStreak || 0);
      entry.maxStreak = Math.max(entry.maxStreak || 0, lp.bestStreak);

      // persist
      saveLifetimeStats(lifetime);
      saveLeaderboard(list);

      // update displayed stats & leaderboards
      renderPrivateStatsFor(playerName);
      renderLeaderboard();
    }

    /* Player handling */
    function sanitizeName(n){ return n ? String(n).trim().replace(/\s+/g,' ').slice(0,32) : ''; }

    function loadPlayer(){
      try { return localStorage.getItem(PLAYER_KEY); } catch(e){ return null; }
    }
    function savePlayer(name){
      try { localStorage.setItem(PLAYER_KEY, name); return true; } catch(e){ return false; }
    }

    function setPlayer(name){
      const s = sanitizeName(name);
      if (!s){
        playerFeedbackEl.textContent = 'Please enter a name.';
        playerFeedbackEl.className = 'player-feedback error';
        return;
      }
      if (!savePlayer(s)){
        playerFeedbackEl.textContent = 'Could not save player (storage unavailable).';
        playerFeedbackEl.className = 'player-feedback error';
        return;
      }
      currentPlayerEl.textContent = s;
      playerFeedbackEl.textContent = 'Player set: ' + s;
      playerFeedbackEl.className = 'player-feedback success';

      // Ensure session structure exists
      if (!sessionStats[s]) sessionStats[s] = { attemptsByType: {}, correctByType: {}, currentStreak: 0, bestStreak: 0 };

      renderPrivateStatsFor(s);
      renderLeaderboard();
    }

    function resetPlayer(){
      try { localStorage.removeItem(PLAYER_KEY); } catch(e){}
      currentPlayerEl.textContent = 'Guest';
      playerInput.value = '';
      playerFeedbackEl.textContent = 'Player reset to Guest.';
      playerFeedbackEl.className = 'player-feedback';
    }

    /* New question generator */
    function newQuestion(){
      const selected = questionTypeSelect.value || 'random';
      answerFeedbackEl.textContent = '';
      solutionStepsEl.style.display = 'none';
      solutionStepsEl.innerHTML = '';
      answerInput.value = '';
      questionMetaEl.textContent = '';

      const types = QUESTION_TYPES;
      const typeChoice = (selected === 'random') ? types[Math.floor(Math.random()*types.length)] : selected;

      let info, prompt;
      if (typeChoice === 'mass-mass'){
        if (Math.random() < 0.5){
          const mH2 = Number((Math.random()*(48) + 2).toFixed(2));
          info = REACTIONS[0].computeMassFromH2(mH2);
          prompt = `How many grams of H₂O are formed from ${mH2} g of H₂?`;
          currentQuestion = { type: typeChoice, prompt, correct: info.value, unit: info.unit, steps: info.steps, eq: REACTIONS[0].eq };
        } else {
          const mC = Number((Math.random()*(39) + 1).toFixed(2));
          info = REACTIONS[1].computeMassFromC(mC);
          prompt = `How many grams of CO₂ are formed from ${mC} g of C?`;
          currentQuestion = { type: typeChoice, prompt, correct: info.value, unit: info.unit, steps: info.steps, eq: REACTIONS[1].eq };
        }
      } else if (typeChoice === 'mass-gas'){
        const mC = Number((Math.random()*(39) + 1).toFixed(2));
        info = REACTIONS[1].computeVolumeCO2FromC(mC);
        prompt = `What volume (L) of CO₂ is formed from ${mC} g of C? (use ${MOLAR_VOLUME} L mol⁻¹)`;
        currentQuestion = { type: typeChoice, prompt, correct: info.value, unit: info.unit, steps: info.steps, eq: REACTIONS[1].eq };
      } else if (typeChoice === 'gas-gas'){
        const vH2 = Number((Math.random()*(9) + 1).toFixed(2));
        info = REACTIONS[0].computeO2FromH2Volume(vH2);
        prompt = `What volume (L) of O₂ is required to react with ${vH2} L of H₂ (same conditions)?`;
        currentQuestion = { type: typeChoice, prompt, correct: info.value, unit: info.unit, steps: info.steps, eq: REACTIONS[0].eq };
      } else if (typeChoice === 'conc-gpl'){
        const m = Number((Math.random()*(19) + 1).toFixed(2));
        const v = Number((Math.random()*(1.9) + 0.1).toFixed(2));
        info = REACTIONS[2].computeConcentration_g_per_L(m,v);
        prompt = `What is the concentration (g L⁻¹) when ${m} g of NaCl is dissolved in ${v} L?`;
        currentQuestion = { type: typeChoice, prompt, correct: info.value, unit: info.unit, steps: info.steps, eq: REACTIONS[2].eq };
      } else if (typeChoice === 'conc-mol'){
        const m = Number((Math.random()*(19) + 1).toFixed(2));
        const v = Number((Math.random()*(1.9) + 0.1).toFixed(2));
        info = REACTIONS[2].computeConcentration_mol_per_L(m,v,M_NaCl);
        prompt = `What is the concentration (mol L⁻¹) when ${m} g of NaCl (M = ${M_NaCl}) is dissolved in ${v} L?`;
        currentQuestion = { type: typeChoice, prompt, correct: info.value, unit: info.unit, steps: info.steps, eq: REACTIONS[2].eq };
      } else {
        return newQuestion();
      }

      questionTextEl.textContent = currentQuestion.prompt;
      questionMetaEl.textContent = currentQuestion.eq ? 'Balanced equation: ' + currentQuestion.eq : '';
      answerUnitEl.textContent = currentQuestion.unit || '';
    }

    /* Answer checking updates stats/streaks/lifetime */
    function checkAnswer(){
      if (!currentQuestion){
        answerFeedbackEl.textContent = 'No question: click New question.';
        answerFeedbackEl.className = 'feedback';
        return;
      }
      const raw = answerInput.value;
      if (raw === '' || raw === null){
        answerFeedbackEl.textContent = 'Enter a numeric answer.';
        answerFeedbackEl.className = 'feedback incorrect';
        return;
      }
      const userVal = Number(raw);
      if (!isFinite(userVal)){
        answerFeedbackEl.textContent = 'Enter a valid number.';
        answerFeedbackEl.className = 'feedback incorrect';
        return;
      }

      const correctVal = currentQuestion.correct;
      const result = isAcceptable(userVal, correctVal);
      const player = loadPlayer() || 'Guest';

      if (result.ok){
        answerFeedbackEl.textContent = `Correct — ${result.reason}. (Correct: ${toSignificantString(correctVal,3)} or ${toSignificantString(correctVal,2)} ${currentQuestion.unit})`;
        answerFeedbackEl.className = 'feedback correct';
        solutionStepsEl.innerHTML = currentQuestion.steps.map(s => `<p>${escapeHtml(s)}</p>`).join('');
        solutionStepsEl.style.display = 'block';

        recordResult(player, 10, currentQuestion.type, true);
      } else {
        answerFeedbackEl.textContent = `Not correct. Your answer (3 s.f.) ${toSignificantString(userVal,3)} vs correct (3 s.f.) ${toSignificantString(correctVal,3)}.`;
        answerFeedbackEl.className = 'feedback incorrect';
        solutionStepsEl.innerHTML = currentQuestion.steps.map(s => `<p>${escapeHtml(s)}</p>`).join('');
        solutionStepsEl.style.display = 'block';

        recordResult(player, -2, currentQuestion.type, false);
      }
    }

    /* Initialization */
    function init(){
      setPlayerBtn.addEventListener('click', ()=> setPlayer(playerInput.value));
      resetPlayerBtn.addEventListener('click', resetPlayer);
      newQuestionBtn.addEventListener('click', newQuestion);
      checkAnswerBtn.addEventListener('click', checkAnswer);

      playerInput.addEventListener('keydown', (e)=> { if (e.key === 'Enter') setPlayer(playerInput.value); });
      answerInput.addEventListener('keydown', (e)=> { if (e.key === 'Enter') checkAnswer(); });

      clearLeaderboardBtn.addEventListener('click', ()=>{
        if (confirm('Clear leaderboard and lifetime stats in this browser?')){
          saveLeaderboard([]);
          saveLifetimeStats({});
          renderLeaderboard();
          const savedPlayer = loadPlayer();
          if (savedPlayer) renderPrivateStatsFor(savedPlayer);
        }
      });

      // load saved player and initialize session
      const saved = loadPlayer();
      if (saved){
        const s = sanitizeName(saved);
        currentPlayerEl.textContent = s;
        playerInput.value = s;
        playerFeedbackEl.textContent = 'Loaded saved player: ' + s;
        playerFeedbackEl.className = 'player-feedback success';
        if (!sessionStats[s]) sessionStats[s] = { attemptsByType: {}, correctByType: {}, currentStreak: 0, bestStreak: 0 };
        renderPrivateStatsFor(s);
      } else {
        currentPlayerEl.textContent = 'Guest';
      }

      renderLeaderboard();
    }

    init();

    // expose for debug (optional)
    window._stoich = { newQuestion, checkAnswer, REACTIONS, M_NaCl, MOLAR_VOLUME };

  })();
  </script>
</body>
</html>
